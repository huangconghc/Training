### 一.java集合类体系
#### （一）集合的理解和好处
（1）集合：就是一种容器，用于保存一组元素。jva集合类包含在java.util包下。

（2）集合和数组对比：

数组：

    1.数组的长度必须提前指定，且一旦指定就不能更改。
    2.数组只能保存相同类型的元素。
    3.比较适合保存基本类型。

集合：

    1. 集合使用时，长度不用指定，而且可以实现自动扩容。
    2.集合没有指定泛型前，默认保存的是任意类型的元素（Object类型），指定泛型之后可以保存对应类型的元素。
    3.比较合适保存引用类型。

#### （二）常用集合的分类
##### （1）Collection 接口（单列集合）

    （1）.List接口：元素有序，可重复。
        1.LinkedList：接口实现类，链表，比较适合插入删除，没有同步，线程不安全。
        2.ArrayList：接口实现类，动态数组，比较适合查询访问，没有同步，线程不安全。
        3.Vector：接口实现类，动态数组，同步，线程安全。
    （2）.Set接口：里面元素不可重复，并做内部排序
        1.HashSet：使用hash表来存储元素
            a.LinkedHashSet：哈希表和链表实现了Set接口，具有可预测的迭代次序。
        2.TreeSet：底层实现为二叉树。
        
##### （2）Map接口，键值对集合（双列集合）
    
    (1).Hashtable：实现了一个哈希表，将键映射到值，任何null对象都可以用作键值或值。线程安全。
    (2).HashMap：基于哈希表的实现的Map接口，与Hanshtable相似，不同在于线程不安全。
        1.LinkedHashMap：哈希表和双向链表实现的Map接口。
        2.WeakHashMap:基于哈希表的Map接口实现，具有弱键。（当某个键不再正常使用时，会被从WeakHashMap中被自动移除）。其他和HashMap一样。
    (3).TreeMap:一个红黑树基于NabigableMap实现。红黑树对所有的key进行排序。
        1.IdentityHashMap:实现Map接口利用哈希表，比较键（和值）时使用引用相等代替对象相等。
        
#### （三）深入理解常用集合
##### （1）List接口的实现类：
    （1）ArrayList
            1.底层结构：可变数组
            2.jdk8：ArrayList中维护了Object[] elementData,初始容量为0，第一次添加时，将初始elementData的容量为10，再次添加时，如果容量足够，则不用扩容直接将新元素赋值到第一个空位上。如果容量不够，会扩容1.5倍。
            3.jdk1.7：ArrayList中维护了Object[] elementData,初始容量为10。添加时，如果容量足够，则不用扩容直接将新元素赋值到第一个空位上。如果容量不够，会扩容1.5倍。
            4.jdk7和jdk8中的区别：
              a.jdk7相当于饿汉式，创建对象时，初始容量为10.
              b.jdk8相当于懒汉式，创建对象时，没有设置初始容量为10，而在添加时才去设置。
            5.查询块，增删慢，线程不安全，效率高，可以重复存储元素。
    （2）LinkedList：
            1.底层实现：双向链表
            2.LinkedList中维护了两个重要的属性 first和last，分别指向首节点和尾结点。每个节点（Node类型）里面有维护了三个属性item、next、prev，分别指向当前元素、下一个、上一个元素。
            3.查询慢，增删快，线程不安全可以存储重复元素。
    （3）Vector：
            1.底层实现：可变数组
            2.线程安全，效率较低，默认容量大小是10，以两倍的数值扩容。
            
#####  （2）Set接口的实现类
    （1）HashSet：
            1.底层结构：维护了一个HashMap对象，也就是和HashMap底层一样，基于哈希表节实现的
            2.无序性，线程不安全，集合元素可以为null，不可重复。
            3.底层通过调用hashCode方法和equals方法实现去重。首先调用hashCode，如果不相等，就直接添加。如果相等则继续判断equals。如果不相等则可以添加，否则返回false。
            
    （2）LinkedHashSet：
            继承自HashSet，不同在于，LinkdHashSet内部使用的是LinkedHashMap，且元素顺序是可以保证的。
    （3）TreeSet：
            1.底层结构：底层维护了一个TreeMap，而TreeMap底层是红黑树。
            2.可自定义排序规则，非线程安全。
            3.对于元素之间排序，如果不指定自定义比较器Comparator，那么插入的对象必须实现Comparable接口。如果指定了自定义比较器，则优先使用。
            4.元素不允许重复，里面不允许为null。
            5.自然排序：必须让添加元素的类型实现Comparable接口，实现里面的compare方法。
            6.定制排序：创建TreeSet对象时，传入一个Comparator接口对象，并实现xompare方法。
##### （3）Map接口的实现类
    （1）Hashtable：
            1.底层结构：哈希表
            2.线程安全，不能接受null键和值。
            3.其他和HashMap一样。
    （2）HashMap：
            1.底层结构：
                jdk1.7：数组+链表
                jdk1.8：数组+链表+红黑树
            2.原理：
                jdk1.8：HashMap维护了Node类型的数组table，当HashMap创建对象时，只是对loadFactory初始化为0.75；table还是保持默认值null；
                当一次添加时，将初始table容量为16，临界值为12，每次添加调用putval方法时：
                    先获取key的二次哈希值并进行取与运算，得出存放位置
                    判断该存放位置上是否有元素，如果没有直接存放。如果该存放位置上已有元素，则继续判断，如果和当前元素相等，则覆盖。如果不相等，就继续判断是否是链表结构还是树状结构，按照对应结构的判断方式进行判断。如果有相等就覆盖，没有就追加上去。
                    后将size更新，判断是否超过了临界值，过了就需要更新resize（）进行两倍扩张，并打乱原来的顺序，重新排序。
                    当一个的桶中的链表的节点数>=8 && 桶的总个数(即table的容量)>=64时，会将链表结构变成红黑树结构。
                 jdk1.7和1.8的区别：
                    a.jdk1.7：创建HashMap对象时，则初始table容量为16
                      jdk1.8：创建HashMap对象时，没有初始化table，仅仅只是初始加载因子，只有当第一次添加时才会初始化table容量为16.
                    b.jdk1.7：数组加链表
                      jdk1.8：数组、链表加红黑树。
            3.迭代HashMap的顺序并不是HashMap放置的顺序，也就是无序。
    （3）LinkedHashMap:
            1.底层结构：数组，双向链表，红黑树
            2.非线程安全，有序，键和值都允许为空，Key重复会覆盖、Value允许重复。
            
    （4）WeakHashMap：
            1.底层结构：哈希表
            2.键和值都可以是null，键是弱引用对象
            3.WeakHashMap特别适用于需要缓存的场景，当一个键对象被垃圾回收器回收时，那么相应的值对象的引用会从Map中删除。
            4.调用两次size()方法返回不同的值。
    （5）TreeMap：
            1.底层结构：红黑树
            2.实现了java.io.Serializable接口，支持序列化
            3.实现了Cloneable接口，能被克隆
            4.非线程安全
##### （4）Queue接口的实现类
    （1）概述：Queue是继承了Collection和Iterable接口的一种队列结构集合。
    （2）PriorityQueue实现类（优先队列）：
        1.PriorityQueue，是基于栈结构的优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取最小元素）。
        2.实现原理：通过堆实现，具体说是通过完全二叉树实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为PriorityQueue的底层实现，不允许放入null元素。
        3.线程不安全，所以 Java 提供了 PriorityBlockingQueue(实现 BlockingQueue接口)用于Java 多线程环境。
        4.PriorityQueue 的大小是不受限制的，但在创建时可以指定初始大小。当我们向优先队列增加元素的时候，队列大小会自动增加。
##### （5）并发容器
    （1）ConcurrentHashMap实现类：
        1.ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。
        2.Segment是一种可重入锁ReentrantLock，结构和HashMap类似，是一种数组和链表结构。HashEntry则用于存储键值对数据
        3.一个ConcurrentHashMap里包含一个Segment数组，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。
        4.JDK6中采用一种更加细粒度的加锁机制Segment分段锁，JDK8椎间盘美化采用CAS无锁算法。
    （2）CopyOnWriteArrayList：
        1.ArrayList的线程安全变体，允许元素为null。
        2.优点：保证多线程的并发读写的线程安全。
        3.缺点：
            内存：有数组拷贝自然有内存问题。如果实际应用数据比较多，而且比较大的情况下，占用内存会比较大，这个可以用ConcurrentHashMap来代替。
            数据一致性：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器
        4.应用场景：遍历操作远多于修改、内存开销可忽略
    （3）CopyOnWriteArraySet：
        1.目标：代替synchronizedSet
        原理：基于CopyOnWriteArrayList实现，其唯一的不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法。
    （4）ConcurrentSkipListMap：
        1.目标：代替synchronizeSortedMap、TreeMap
        2.原理：Skip list（跳表）是一种可以替代平衡数的数据结构，默认是按照key值升序。ConcurrentSkipListMap提供了一种线程安全得并发访问的排序映射表。
##### （6）Collections工具类：
    （1）Collections事宜个操作Set、List和Map等集合的工具类。
    （2）Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。
### 二.java异常处理
#### （一）异常分类：
        （1）Throwable：是所有异常类的根。所有java异常类都直接或间接继承自Throwable。包含Error和Exception两个类型。
    （2）Error：是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。
        包含Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。非代码性错误。因此，当此类错误发生时，应用不应该去处理此类错误。
    （3）Exception：程序本身可以捕获并且可以处理的异常。包含运行时异常(不受检异常)RuntimeException和非运行时异常(受检异常)checked异常。
        1.RuntimeException：其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）等。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。
        2.非RuntimeException：Exception中除RuntimeException及子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。
#### （二）异常处理
#####   （1）抛出异常：
        （1）Throws：
            1.用在方法声明后面，跟的是异常类名
            2.由该方法的调用者来处理。
            3.表示出现异常的一种可能性，并不一定会发生。
        （2）Throw：
            1.用在方法体内，跟的是异常对象名。
            2.由方法体内的语句处理。
            3.执行throw一定抛出了某种异常。
##### （2）捕获异常：try，catch，finally
        （1）try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。
    （2）每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。
    （3）java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。
    （4）finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。
        1.finally块没有处理异常的能力。处理异常的只能是catch块。
        2.在同一try...catch...finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。
        3.在同一try...catch...finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。
#### （三）自定义异常
##### （1）自定义类继承Exception
        （1）继承Exception原因：因为异常类和异常对象都被抛出。他们都具备可抛性，这个可抛性是Throwable这个体系中独有特点。只有这个体系中的类和对象才可以被throws和throw操作。
    （2）重写构造方法。

### 三.Maven专题
#### （一）什么是Maven
        Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具，简单的说就是用来管理项目所需要的依赖且管理项目构建的工具。
#### （二）Maven的优势
#####   （1）约定优于配置
#####   （2）使用简单
##### （3）支持测试
#####   （4）构建简单
#####   （5）插件丰富
#### （三）Maven的安装配置
#####   （1）在官网下载安装包：http://maven.apache.org/download.cgi
#####   （2）配置环境变量MAVEN_HOME=maven的解压后的目录
##### （3）在变量Path的开头增加"%MAVEN_HOME%\bin;"
#####   （4）在MAVEN_HOME/conf/setting.xml文件中通过<localRepository></localRepository>标签配置本地仓库的位置
#### （四）Maven规定的目录结构
    1.src 目录是源代码和测试代码的根目录。
    2.main 目录是与源代码相关的根目录到应用程序本身，而不是测试代码。
    3.test 目录包含测试源代码。
    4.main和test下的 java 目录包含Java代码的应用程序本身是在main和用于测试的Java代码。
    5.resources 目录包含您项目所需的资源。
    6.target 目录由Maven创建。它包含所有编译的类，JAR文件等。
    7.当执行 mvn clean 命令时，Maven将清除目标目录。
    8.webapp 目录包含Java Web应用程序，如果项目是Web应用程序。webapp 目录是Web应用程序的根目录。webapp目录包含 WEB-INF 目录。
####    （五）Maven基本命令
    1.-v:查询Maven版本，本命令用于检查maven是否安装成功。 Maven安装完成之后，在命令行输入mvn-v，若出现maven信息，则说明安装成功。
    2.compile：编译 将Java源文件编译成class文件
    3.test:测试项目 执行test目录下的测试用例
    4.package:打包将项目打成jar包
    5.clean:删除target文件夹
    6.install:安装将当前项目放到Maven的本地仓库中。供其他项目使用
####     （六）什么是Maven仓库？
#####     （1）Maven仓库用来存放Maven管理的所有Jar包。分为：本地仓库 和 中央仓库。
            （1）本地仓库：Maven本地的Jar包仓库。
            （2）中央仓库：Maven官方提供的远程仓库。
#####     （2）当项目编译时，Maven首先从本地仓库中寻找项目所需的Jar包，若本地仓库没有，再到Maven的中央仓库下载所需Jar包。
####     （七）什么是坐标？
##### （1）在Maven中，坐标是Jar包的唯一标识，Maven通过坐标在仓库中找到项目所需的Jar包。 
        （1）栗子：
    <dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.1.1</version>
    </dependency>
    （2）groupId:所需Jar包的项目名
    （3）artifactId:所需Jar包的模块名
    （4）version:所需Jar包的版本号
#####     （2）传递依赖 与 排除依赖
        （1）传递依赖：如果我们的项目引用了一个Jar包，而该Jar包又引用了其他Jar包，那么在默认情况下项目编译时，Maven会把直接引用和间接引用的Jar包都下载到本地。
    （2）排除依赖：如果我们只想下载直接引用的Jar包，那么需要在pom.xml中做如下配置：(将需要排除的Jar包的坐标写在中)
    <exclusions>
    <exclusion>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
    </exclusion>
    </exclusions>
#####     （3）依赖冲突
            （1）若项目中多个Jar同时引用了相同的Jar时，会产生依赖冲突，但Maven采用了两种避免冲突的策略，因此在Maven中是不存在依赖冲突的。
                1.短路优先:
                本项目——>A.jar——>B.jar——>X.jar
                本项目——>C.jar——>X.jar
                若本项目引用了A.jar，A.jar又引用了B.jar，B.jar又引用了X.jar，并且C.jar也引用了X.jar。 在此时，Maven只会引用引用路径最短的Jar。
                2.声明优先 :
                若引用路径长度相同时，在pom.xml中谁先被声明，就使用谁。
#####         (4）聚合    
                （1）什么是聚合？
            将多个项目同时运行就称为聚合。
    （2）如何实现聚合？ 
            只需在pom中作如下配置即可实现聚合：
        <modules>
        <module>../模块1</module>
        <module>../模块2</module>
        <module>../模块3</module>
        </modules>
#####         （5）继承
        （1）什么是继承？ 
            在聚合多个项目时，如果这些被聚合的项目中需要引入相同的Jar，那么可以将这些Jar写入父pom中，各个子项目继承该pom即可。
    （2）如何实现继承？
            1.父pom配置：将需要继承的Jar包的坐标放入标签即可。
        <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.apache.shiro</groupId>
                <artifactId>shiro-spring</artifactId>
                <version>1.2.2</version>
            </dependency> 
        </dependencies>
        </dependencyManagement>
            2.子pom配置：
        <parent>
        <groupId>父pom所在项目的groupId</groupId>
        <artifactId>父pom所在项目的artifactId</artifactId>
        <version>父pom所在项目的版本号</version>
         </parent>
####     (八)Maven的生命周期
#####     （1）概述：Maven的生命周期是抽象的，maven生命周期本身不做任何实际的工作。生命周期的每个阶段的具体工作都是由绑定的插件的插件目标来完成。
##### （2）三套生命周期：maven有三套相互独立的生命周期，分别为clean、default和site。
        （1）clean生命周期负责项目清理，包含三个阶段：
            1.预清洁（pre-clean）：执行实际项目清理之前所需的流程
            2.清洁（clean）：删除以前构建生成的所有文件
            3.后清洁（post-clean）：执行完成项目清理所需的流程
    （2）默认（default）生命周期：
            1.验证（validate）：验证项目是正确的，所有必要的信息可用。
            2.初始化（initialize）：初始化构建状态，例如设置属性或创建目录。
            3.产生来源（generate-sources）：生成包含在编译中的任何源代码。
            4.流程源（process-sources）：处理源代码，例如过滤任何值。
            5.生成资源（generate-resources）：生成包含在包中的资源。
            6.流程资源（process-resources）：将资源复制并处理到目标目录中，准备打包。
            7.编译（compile）：编译项目的源代码。
            8.工艺类（process-classes）：从编译后处理生成的文件，例如对Java类进行字节码增强。
            9.生成测试来源（generate-test-sources）：生成包含在编译中的任何测试源代码。
            10.流程测试来源（process-test-sources）：处理测试源代码，例如过滤任何值。
            11.生成测试资源（generate-test-resources）：创建测试资源。
            12.流程测试资源（process-test-resources）：将资源复制并处理到测试目标目录中。
            13.测试编译（test-compile）：将测试源代码编译到测试目标目录中
            14.流程检验类（process-test-classes）：从测试编译中处理生成的文件，例如对Java类进行字节码增强。对于Maven 2.0.5及以上版本。
            15.测试（test）：使用合适的单元测试框架运行测试。这些测试不应该要求代码被打包或部署。
            16.制备包（prepare-package）：在实际包装之前，执行必要的准备包装的操作。这通常会导致打包的处理版本的包。（Maven 2.1及以上）
            17.打包（package）：采取编译的代码，并以其可分发的格式（如JAR）进行打包。
            18.预集成测试（pre-integration-test）：在执行集成测试之前执行所需的操作。这可能涉及诸如设置所需环境等。
            19。集成测试（integration-test）：如果需要，可以将该包过程并部署到可以运行集成测试的环境中。
            20.整合后的测试（post-integration-test）：执行集成测试后执行所需的操作。这可能包括清理环境。
            21.校验（verify）：运行任何检查以验证包装是否有效并符合质量标准。
            22.安装（install）：将软件包安装到本地存储库中，以作为本地其他项目的依赖关系。
            23.部署（deploy）：在集成或发布环境中完成，将最终软件包复制到远程存储库，以与其他开发人员和项目共享。
     （3）站点（site）生命周期
            1.预网站（pre-site）：在实际的项目现场生成之前执行所需的进程
            2.网站（site）：生成项目的站点文档
            3.后网站（post-site）：执行完成站点生成所需的进程，并准备站点部署
            4.网站部署（site-deploy）：将生成的站点文档部署到指定的Web服务器

### 四.类与接口
#### （一）类
##### （1）概念：类是一个模板，它描述一类对象的行为和状态。
##### （2）对象的含义：对象是类的一个实例，有状态和行为。比如：人是一个对象，他有姓名、年龄职业的状态。走路、吃饭、工作就是他的行为。
#####    （3）面向对象的三个特征：
            （1）继承性：在已有的基础上继续进行扩充。
    （2）封装性：保护内部的结构不直接被外部可见。
    （3）多态性：同一个行为具有多个不同表现形式或形态的能力。
#####     （4）类由两个重要组成部分组成：属性和方法
            （1）属性：标识每一个对象的特征，每个对象都有自己的属性。属性实际就是变量。
            1.局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
            2.成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
            3.类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。
    （2）方法：是公共行为，固定的操作。
            1.构造方法：用来初始化一个对象的，并为为实例变量赋予合适的初始值。
            2.成员方法：必须用类的实例化对象进行访问。
            3.全局方法：是直接可以用类名.方法名来访问的。
#####     （5）类的分类：
        （1）抽象类：
            1.用关键字Abstract
            2.目的：若所有子类拥有共同的特性，可以把这个特性放到一个抽象类中，子类继承此抽象类。 3.特点：
                a.不能被实例化；ClassName en=new ClassName();//这样会报错。
                b.抽象成员必须包含在抽象类中。
                c.抽象类除了抽象成员外，还可以包含别的成员(不用关键字 abstract)。
                d.子类继承抽象父类后，必须把父类中的所有抽象成员都重写(非抽象成员不必重写)。除非子类也是个抽象类。
                e.抽象成员的访问修饰符不能是private。
                f.抽象类是有构造函数，虽然不能被实例化。
                g.abstract不能用于字段成员，可定义成属性。
                h.abstract用于方法时，方法不能定义主体(内容)。
                i.抽象类也可以实现接口，但要把接口的成员前面标记个abstract。
        (2)静态类：
            1.关键字：static
            2.使用方法：不需要实例化，可以直接类名引用静态方法。比如 工具类。
            3.特点：静态成员在整个程序退出时才释放资源，所以尽量别写静态字段、属性。最好是静态方法。
    
#### （二）接口
##### （1）概念：就是一个抽象类型，是抽象方法的集合。
##### （2）：接口详叙
    （1）关键字：interface
    （2）目的：抽象类所拥有的共性，也可以概括为：为了多态。
    （3）特点：
        1.接口中只能包含方法。（方法、属性、索引器、事件）
        2.接口中的方法不能有任何实现
        3.接口中的成员不能有任何访问修饰符（哪怕是public）
        4.接口不能被实例化
        5.实现接口的类，必须实现接口的所有成员(这里跟抽象类一样)
        6.类不能多继承，所以在某些情况下，只能用接口来代替。接口可以多实现（一个类可以继承多个接口，而只能继承一个类）
        7.接口的主要目的就是为了实现多态
        8.当一个类，同时继承了某个类，并且也实现了某些接口的时候，必须要将继承的类写在第一个(如果一个类同时继承了父类和接口的时候，要把父类写在最前面)
        9.当多个类，都具有某个或某几个功能时（方法），但是这几个类型又不属于相同的系列（这几个类型没有共同的父类，就不能用抽象类。），所以这时，为了实现多态就可以考虑把这几个类型共有的方法提取到一个接口中，让这几个类型分别实现该接口
        10.当父类实现接口，子类继承父类。那么 接口就可以引用子类
        11.不要在一个接口中写过多的方法，避免造成接口污染。可编写多个接口，在每个接口中，分别定义方法
        12.实现接口方法的时候，不要有override关键字，直接跟平常定义一样
        13.接口方法的显示实现，如果多个接口里有相同的方法名。那么第一个方法名默认的引用的是排在最前面的接口，如果要使用后面接口的方法，就要显示实现：接口名.方法名。访问修饰符是private
##### （3）接口的使用
    （1）由于接口里面存在抽象方法，所以接口对象不能直接使用关键字new进行实例化。
    （2）接口必须要有子类，但此时一个子类可以使用implements关键字实现多个接口。
    （3）接口的子类（如果不是抽象类），那么必须要覆写接口中的全部抽象方法。
    （4）接口的对象可以利用子类对象的向上转型进行实例化。
#####     （4）接口与类的关系
        （1）接口和接口之间可以多继承，并且可以多层继承。
    （2）接口和类可以单实现，也可以多实现。
        1.如果多个接口中有同名的抽象方法,那么实现类只需要实现一次就行。
        2.如果多个接口中有同名的静态方法,那么实现类不用去理,接口中的静态方法只供接口直接使用。
        3.如果多个接口中有同名的私有方法,那么实现类不用去理,因为接口中的私有方法只能在本接口中使用
    （3）当一个父类派生出5个子类时，所有子类中只有3个需要一个功能，也就是说不是所有的子类都需要此功能，那么就可以把次功能放到一个接口里，各子类进行单独的实现。接口为了更好的约束子类。






    
        
            

        
